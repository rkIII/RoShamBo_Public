
\section{Experiments}
\label{sec:expts}

	In the early stages of building our bot we experimented with a number of different strategies. In early attempts at creating a bot we focused on writing more simple algorithms. Our first three bots were simple AI bots called Bot1, NewBot, and OpponentRepeatsBot. Bot1 implemented a frequency analysis algorithm where the bot would log the opponents last n moves, and would play the move that beat the Opponents most frequently played move. After testing different values for n, we chose to use 20 as the number of moves we would log. This bot's performance was underwhelming, placing 19th out of 23 bots with score of 13 and win margin of -32523. NewBot implemented repetition recognition. The idea behind this bot was that a human player would rarely throw the same move three times in a row. This bot would check to see if the last two opponent throws were the same and if they were, it would exclude the repeated from its possible move set and flip a coin to predict which of the other two moves the opponent would throw. This bot placed 15th in prelims with a score of 20 and a win margin of -9681. Our best performing bot in the preliminary tournament was OpponentRepeatsBot that always assumed the opponent would repeat its last move. It placed 13th with a score of 21 and win margin of 7643.
	After the preliminary tournament, we devised a more robust AI bot that learned its opponent's tendencies as it played. Our bot, nicknamed CrockBot, is based off of the Iocaine Powder strategy.  CrockBot uses a modified version of History Matching and Frequency Analysis. CrockBot's first resort is a History Matching Algorithm that uses pattern recognition to see if the opponent has made the most recent sequence of moves at some point earlier in the match. If CrockBot finds the sequence of moves elsewhere in the opponent's move history, it predicts that the opponent will throw the move it has thrown most frequently after the given sequence.  We chose to use the Pattern Recognition as the first resort because we felt that humans tend to fall into ruts during long competitions and repeat their moves. If CrockBot fails to find the most recent pattern of moves, then it resorts to a modified Frequency Analysis. CrockBot's frequency analysis algorithm uses a constantly changing probability distribution. It keeps track of how many times the opponent throws each move, how many rounds have been played, and updates these counters after every turn. Every three turns, the Bot recalculates the probabilities for which it chooses rock, paper, or scissors based on the number of total moves and the number of times each move is thrown. Effectively, the  new probability of throwing Rock would be the number of times the opponent threw rock divided by the total number of moves. CrockBot then uses the new probability distribution to predict the next three turns. 
	While developing CrockBot, we needed to test our parameters for each decision making process. In the History Matching process, we aimed to find the desired 'look back' value, i.e., how long of a pattern should we match for pattern recognition selection to be effective. We found that for values five and under in a ten-thousand round match, pattern recognition was used too frequently. For values over 10, patterns were too difficult to match so pattern recognition was rendered ineffective and CrockBot's win margin over the test bots decreased. We settled on a window size of 7. This gave us a desired proportion of choosing using the frequency distribution and pattern recognition when needed. In our frequency distribution selection method, we settled on a value of 3 as the window. This value was chosen arbitrarily after some testing because the window size did not change our results against test bots.
	